<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.23">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Research – Language, Cognition, and Computation Lab</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js" type="module"></script>
<script src="site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-1fe81d0376b2c50856e68e651e390326.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-5b4ad623e5705c0698d39aec6f10cf02.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="styles.css">
</head>

<body class="nav-fixed fullcontent quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a href="./index.html" class="navbar-brand navbar-brand-logo">
    <img src="./images/logo.png" alt="" class="navbar-logo light-content">
    <img src="./images/logo.png" alt="" class="navbar-logo dark-content">
    </a>
    <a class="navbar-brand" href="./index.html">
    <span class="navbar-title">Language, Cognition, and Computation Lab</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="./index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link active" href="./research.html" aria-current="page"> 
<span class="menu-text">Research</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./people.html"> 
<span class="menu-text">People</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./join.html"> 
<span class="menu-text">Join</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Research</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p>The Language, Cognition, and Computation (LCC) Lab investigates research questions at the intersection of Psychology and AI. We use tools like large language models (LLMs) as “model organisms” to study human cognition; in turn, we apply theories and methods from Psychology to better understand how LLMs work under the hood.</p>
<p>A (non-exhaustive) sample of ongoing research programs is listed below.</p>
<p><strong>Research areas:</strong> <a href="#mental-state-reasoning-in-humans-and-language-models">Mental state reasoning</a> · <a href="#representation-and-processing-of-lexical-ambiguity">Lexical ambiguity</a> · <a href="#epistemological-foundations-of-llm-ology">Epistemology</a> · <a href="#embodiment-and-conceptual-knowledge">Embodiment</a> · <a href="#calibration-and-trust">Calibration and trust</a></p>
<div class="research-section">
<section id="mental-state-reasoning-in-humans-and-language-models" class="level3 section-header">
<h3 class="anchored" data-anchor-id="mental-state-reasoning-in-humans-and-language-models">Mental state reasoning in humans and language models</h3>
<p>What can we learn by comparing the behavior of humans and language models on mental state reasoning tasks?</p>
</section>
<p>Humans regularly reason about the belief states of others. But how do we acquire this capacity? One hypothesis is that it emerges in part from <em>exposure to language</em>. We use LLMs trained on the distributional statistics of language to ask whether, when, and why sensitivity to belief states reliably emerges from this training protocol. We also investigate the <em>developmental trajectory</em> and <em>mechanistic underpinnings</em> of this behavior in LLMs to better understand the phenomenon in both LLMs and humans.</p>
<p><strong>Selected papers:</strong></p>
<ul>
<li>Trott, S., Jones, C., Chang, T., Michaelov, J., &amp; Bergen, B. (2023). Do Large Language Models know what humans know? <em>Cognitive Science.</em> <a href="https://onlinelibrary.wiley.com/doi/full/10.1111/cogs.13309">[Link]</a></li>
<li>Jones, C. R., Trott, S., &amp; Bergen, B. (2024). Comparing Humans and Large Language Models on EPITOME. <em>Transactions of the Association for Computational Linguistics, 12, 803-819.</em> <a href="https://direct.mit.edu/tacl/article/doi/10.1162/tacl_a_00674/122721">[Link]</a></li>
</ul>
</div>
<div class="research-section">
<section id="representation-and-processing-of-lexical-ambiguity" class="level3 section-header">
<h3 class="anchored" data-anchor-id="representation-and-processing-of-lexical-ambiguity">Representation and processing of lexical ambiguity</h3>
<p>How do humans and language models represent the multiple meanings of ambiguous words?</p>
</section>
<p>Most words are <em>ambiguous</em>, i.e., they mean different things in different contexts. Ambiguity raises a challenge for comprehension, but it’s also an opportunity for research: it provides a <em>window</em> into the representations and mechanisms underlying the contextualization of meaning. In humans, our work focuses on the <em>format</em> of meaning representations (e.g., are they discrete or continuous?). In language models, we focus on the <em>internal mechanisms</em> responsible for disambiguation (e.g., specific attention heads).</p>
<p><strong>Selected papers:</strong></p>
<ul>
<li>Rivière, P., &amp; Trott, S. (2026). Start Making Sense(s): A Developmental Probe of Attention Specialization Using Lexical Ambiguity. <em>Transactions of the Association for Computational Linguistics.</em> <a href="https://arxiv.org/abs/2511.21974">[Link]</a> <a href="https://github.com/seantrott/entangled_meanings">[Code and data]</a></li>
<li>Rivière, P. D., Beatty-Martínez, A. L., &amp; Trott, S. (2025, April). Evaluating Contextualized Representations of (Spanish) Ambiguous Words: A New Lexical Resource and Empirical Analysis. In <em>Proceedings of the 2025 Conference of the Nations of the Americas Chapter of the Association for Computational Linguistics: Human Language Technologies (Volume 1: Long Papers) (pp.&nbsp;8322-8338)</em>. <a href="https://aclanthology.org/2025.naacl-long.422/">[Link]</a> <a href="https://github.com/seantrott/spanish_norms">[Code]</a> <a href="https://huggingface.co/datasets/seantrott/sawc">[HuggingFace dataset]</a></li>
<li>Trott, S., &amp; Bergen, B. (2023). Word meaning is both categorical and continuous. <em>Psychological Review, 130(5), 1239</em>. <a href="https://www.researchgate.net/profile/Sean-Trott/publication/369116867_Word_meaning_is_both_categorical_and_continuous/links/656dfb46a760eb7cc748b026/Word-Meaning-Is-Both-Categorical-and-Continuous.pdf">[Link]</a> <a href="https://github.com/seantrott/trott_ph_amb">[Code and data]</a></li>
<li>Trott, S., &amp; Bergen, B. (2021, August). RAW-C: Relatedness of Ambiguous Words in Context (A New Lexical Resource for English). In <em>Proceedings of the 59th Annual Meeting of the Association for Computational Linguistics and the 11th International Joint Conference on Natural Language Processing (Volume 1: Long Papers) (pp.&nbsp;7077-7087).</em> <a href="https://aclanthology.org/2021.acl-long.550/">[Link]</a> <a href="https://github.com/seantrott/raw-c">[Dataset and code]</a><a href="https://huggingface.co/datasets/seantrott/rawc">[HuggingFace dataset]</a></li>
</ul>
</div>
<div class="research-section">
<section id="epistemological-foundations-of-llm-ology" class="level3 section-header">
<h3 class="anchored" data-anchor-id="epistemological-foundations-of-llm-ology">Epistemological foundations of “LLM-ology”</h3>
<p>Can we develop a systematic, generalizable science of LLMs?</p>
</section>
<p>The use of LLMs in Cognitive Science research is relatively novel, as is the scientific study of LLMs themselves (“LLM-ology”). This raises a number of <a href="https://seantrott.substack.com/p/llm-ology-the-challenges-ahead"><em>epistemological challenges</em></a>:</p>
<ul>
<li>Challenges of <em>measurement</em>: does the same test “mean the same thing” when applied to humans and LLMs, or does it exhibit <em>differential construct validity</em>? What is the <em>functional scope</em> of a particular mechanism?</li>
<li>Challenges of <em>generalizability</em>: what does research on a particular LLM tell us about LLMs more broadly? And in what sense are LLMs “model organisms” for research on human cognition?</li>
<li>Challenges of <em>ontology</em>: what “kind of thing” is an LLM in the first place and what conceptual frameworks are most useful for understanding these systems?</li>
</ul>
<p><strong>Selected papers:</strong></p>
<ul>
<li>Trott, S. Toward a Theory of Generalizability in LLM Mechanistic Interpretability Research. In Mechanistic Interpretability Workshop at NeurIPS 2025. <a href="https://arxiv.org/abs/2509.22831">[Link]</a> <a href="https://github.com/seantrott/mechinterp_generalizability">[Code and data]</a></li>
<li>Trott, S. (2024). Large language models and the wisdom of small crowds. Open Mind, 8, 723-738. <a href="https://direct.mit.edu/opmi/article/doi/10.1162/opmi_a_00144/121179">[Link]</a> <a href="https://github.com/seantrott/llm_clt/">[Code and data]</a></li>
<li>Trott, S., Jones, C., Chang, T., Michaelov, J., &amp; Bergen, B. (2023). Do Large Language Models know what humans know? <em>Cognitive Science.</em> <a href="https://onlinelibrary.wiley.com/doi/full/10.1111/cogs.13309">[Link]</a></li>
</ul>
</div>
<div class="research-section">
<section id="embodiment-and-conceptual-knowledge" class="level3 section-header">
<h3 class="anchored" data-anchor-id="embodiment-and-conceptual-knowledge">Embodiment and conceptual knowledge</h3>
<p>How is conceptual knowledge shaped by <em>sensorimotor</em> and <em>linguistic</em> experience?</p>
</section>
<p>Humans have bodies and move through space. What role do these <em>perceptual</em> and <em>motor</em> experiences play in shaping our conceptual representations? And how do these experiences interact with our knowledge of the symbolic, categorical nature of human language? We use neural networks trained on various <em>input modalities</em> (e.g., <em>vision models</em>, <em>language models</em>, and <em>vision-language models</em>) to ask which best accounts for human conceptual knowledge.</p>
<p><strong>Selected papers:</strong></p>
<ul>
<li>Rivière, P. D., Parkinson-Coombs, O., Jones, C., &amp; Trott, S. (2025, July). Does Language Stabilize Quantity Representations in Vision Transformers? In (Proceedings of the Annual Meeting of the Cognitive Science Society (Vol. 47, No.&nbsp;47)*. <a href="https://escholarship.org/uc/item/8f03g251">[Link]</a></li>
<li>Jones, C. R., Bergen, B., &amp; Trott, S. (2024). Do multimodal large language models and humans ground language similarly?. Computational Linguistics, 50(4), 1415-1440. <a href="https://direct.mit.edu/coli/article/50/4/1415/123786">[Link]</a></li>
<li>Trott, S., &amp; Bergen, B. (2022). Contextualized sensorimotor norms: Multi-dimensional measures of sensorimotor strength for ambiguous English words, in context. <a href="https://arxiv.org/abs/2203.05648">[Link]</a></li>
</ul>
</div>
<div class="research-section">
<section id="calibration-and-trust" class="level3 section-header">
<h3 class="anchored" data-anchor-id="calibration-and-trust">Calibration and trust</h3>
<p>What kinds of <em>mental models</em> do individuals have about the capabilities and limitations of AI tools, and how we can encourage <em>appropriate calibration</em>?</p>
</section>
<p>AI tools like LLMs display seemingly remarkable abilities—but also, in some cases, surprising and inexplicable failures. This makes <a href="https://seantrott.substack.com/p/calibrating-expectations">calibrating our expectations</a> of what these systems can and can’t do very difficult. We study potential <em>use cases</em> of LLMs (e.g., in scientific research) as well as the <a href="https://seantrott.substack.com/p/what-we-talk-about-when-we-talk-about"><em>metaphors</em> and <em>mental models</em></a> individuals form from observing the behavior of LLMs.</p>
<p><strong>Selected papers:</strong></p>
<ul>
<li>Trott, S. (2024). Can large language models help augment English psycholinguistic datasets?. <em>Behavior Research Methods</em>, 56(6), 6082-6100. <a href="https://link.springer.com/article/10.3758/s13428-024-02337-z">[Link]</a> <a href="https://github.com/seantrott/llm_norms">[Code and data]</a></li>
</ul>
</div>



</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>